!! About ==printing== and Streams



!!! About ==printString==
Let us take a moment to step back about stream usage in ==printOn:== methods.
The =printString== method creates a stream and passes this string as argument of the ==printOn:== method as shown below:

[[[
Object >> printString
	"Answer a String whose characters are a description of the receiver. 
	If you want to print without a character limit, use fullPrintString."

	^ self printStringLimitedTo: 50000
]]]

[[[
Object >> printStringLimitedTo: limit
	"Answer a String whose characters are a description of the receiver.
	If you want to print without a character limit, use fullPrintString."

	^self printStringLimitedTo: limit using: [:s | self printOn: s]
]]]


[[[
Object >> printStringLimitedTo: limit using: printBlock
	"Answer a String whose characters are a description of the receiver
	produced by given printBlock. It ensures the result will be not bigger than given limit"

	| limitedString |
	limitedString := String streamContents: printBlock limitedTo: limit.
	limitedString size < limit ifTrue: [^ limitedString].
	^ limitedString , '...etc...'
]]]

What you should see is that the method  ==printStringLimitedTo:using:== is creating a stream and passing it around.

When you redefine the method ==printOn:== in your class, if you send the message  ==printString== on the instance variables of your object, you are in fact creating yet another stream and copying its contents in the first one. 
Here is an example:

[[[
MessageTally >> displayStringOn: aStream
	self displayIdentifierOn: aStream.
	aStream 
		nextPutAll: ' (';
		nextPutAll: self tally printString;
		nextPutAll: ')'
]]]

This is clearly counter productive.
It is much better to send the message ==print:== to the stream or ==printOn:== to the instance variable it as follows: 

[[[
MessageTally >> displayStringOn: aStream
	self displayIdentifierOn: aStream.
	aStream 
		nextPutAll: ' (';
		print: self tally;
		nextPutAll: ')'
]]]



To understand what the method ==print:==, here its definition:

[[[
Stream >> print: anObject
	"Have anObject print itself on the receiver."

	anObject printOn: self
]]]

Pay attention, sending the ==printString== message is often wrong and it is the duties of the system to do it.

!!! Unnecessary stream creation

Here is an example taken from Pharo that is not related to ==printString== but it exhibits exactly the same problem of unnecessary stream creation.

[[[
printProtocol: protocol sourceCode: sourceCode

	^ String streamContents: [ :stream |
		stream
			nextPutAll: '"protocol: '; 
			nextPutAll: protocol printString;
			nextPut: $"; cr; cr;
			nextPutAll: sourceCode ]	
]]]

What you should see is that a stream is created and then another stream is created and discarded with the ==protocol printString==.
A better implementation is 

[[[
printProtocol: protocol sourceCode: sourceCode

	^ String streamContents: [ :stream |
		stream
			nextPutAll: '"protocol: '; 
			print: protocol;
			nextPut: $"; cr; cr;
			nextPutAll: sourceCode ]	
]]]



!!! ==printString== vs. ==displayString==

Newcomers are often confused between ==printString== and ==displayString== and their counterparts ==printOn:== and ==displayStringOn::==.

- ==printString== is used for debugging, that's why the default  implementation shows the class name. It's implemented by specializing ==printOn:== on your classes.
- ==displayString== is used for nicely display objects in list. It is implemented by specializing ==displayStringOn:== on your classes.


If you have aPerson: 
[[[
aPerson printString 
>>> 'aPerson ('John Doe')'
]]]

[[[
aPerson displayString 
>>> 'John Doe' 
]]]


!!! printString vs. asString

The other difficulties you may encounter is to see the difference between ==printString== and ==asString==.

- ==printString== is used for debugging, that's why the default  implementation shows the class name. It's implemented by specializing ==printOn:== on your classes.

- ==asString== converts an object into a string. It is equivalent to the  ==toString()== in other languages.

Let us take an example with the symbol ==#foo==.

Printing the symbol ==#foo== is just printing it as symbol.
[[[
#foo printString 
>>> '#foo'
]]]

Sending the message ==asString== to the symbol ==#foo== converts it to a string.

[[[
#foo asString 
>>>
'foo'
]]]



[[[
'foo' printString
	'foo'
]]]

[[[	
'foo' printString 
	"'''foo'''"
]]]

[[[
'foo''foo' asString
]]]

[[[
'foo''foo' printString 
>>> '''foo''''foo'''
]]]	








!! Understanding Class and instance variable
@@note Not sure that I want to have this session

- instance-variable: A variable that holds the private state of an object.  In Pharo, these can only be accessed by instance-methods. 

- class-variable: An attribute of a class that is shared by that class,  its subclasses, and  all  instances  of  those  classes.  Can  be  accessed  by  both  instance-methods and class-methods. 

- class-instance-variable:  An attribute  of a class that  is not shared outside that specific class. Only the definition is inherited by subclasses, not the value.   Each subclass has its own private value.  Accessible only by class-methods. 

Example: 
We will experiment with three different variables
- ivCounter - instance variable counter 
- CVCounter - class variable counter 
- CIVCounter - class instance variable counter 

[[[
Object subclass: #UnderstandCounter 
    instanceVariableNames: 'ivCounter iName' 
    classVariableNames: 'CVCounter' 
    package: 'MyExamples' 
]]]
[[[
UnderstandCounter class  "accessed by clicking the <Class> button" 
    instanceVariableNames: 'CIVCounter' 

]]]
[[[
UnderstandCounter subclass: #UnderstandSubCounter 
    instanceVariableNames: '' 
    classVariableNames: '' 
    package: 'MyExamples' 
]]]  

[[[
UnderstandCounter >> next 
    ivCounter ifNil: [ ivCounter := 0 ]. 
    CVCounter ifNil: [ CVCounter := 0 ]. 
    ivCounter := ivCounter + 1. 
    CVCounter := CVCounter + 1. 
]]]

[[[
UnderstandCounter >> printOn: aStream 
    super printOn: aStream. 
    aStream nextPutAll: ' ['. 
    aStream 
        print: iName.
    aStream nextPutAll: '] ( '.
    aStream
        nextPutAll: ' ivCounter=';
        print: ivCounter.
    aStream
        nextPutAll: ', CIVCounter=n/a'.
    aStream
        nextPutAll: ', CVCounter=';
        print: CVCounter.
    aStream nextPutAll: ' )'.
]]]


[[[
UnderstandCounter class >> next2
    CIVCounter ifNil: [ CIVCounter := 0 ].
    CVCounter ifNil: [ CVCounter := 0 ].

    CIVCounter := CIVCounter + 1.
    CVCounter := CVCounter + 1.
]]]  

[[[
UnderstandCounter class >> printOn: aStream 
    super printOn: aStream.
    aStream nextPutAll: ' ( '.
    aStream
        nextPutAll: 'ivCounter=n/a'.
    aStream
        nextPutAll: ', CIVCounter=';
        print: CIVCounter.
    aStream
        nextPutAll: ', CVCounter=';
        print: CVCounter.
    aStream nextPutAll: ' )'.
]]]  

[[[  
UnderstandCounter class >> reset 
    CVCounter := nil.
    CIVCounter := nil.
]]]  

Then from Workspace evaluate these...
[[[
tc1 := UnderstandCounter new.
tc2 := UnderstandCounter new.

tsc1 := TestSubCounter new.
tsc2 := TestSubCounter new.

TestCounter reset.
TestSubCounter reset.

tc1 next.
tc2 next.
tc1 next.
tc2 next.

tsc1 next.
tsc2 next.
tsc1 next.
tsc2 next.

TestCounter next2.
TestCounter next2.
TestCounter next2.

TestSubCounter next2.
TestSubCounter next2.
TestSubCounter next2.
]]]